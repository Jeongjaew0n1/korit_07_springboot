# SpringBoot Project 생성
https://start.spring.io
Gradle - Groovy
Java
3.5.6
Artifact com.example.cardatabase
Jar
17

그리고 Add Dependencies click
Spring Web
Spring Boot Dev tools
Lombok
Spring Data JPA

SpringBoot의 간단 설명
Entity의 개념
JPA가 그래서 Entity와 어떻게 연결되어있고, inmemory database인 h2와 어떻게 연결이 되는지 여부도 수업.
build.gradle / application.properties라고 하는 파일들에 명령어들을 작성하게 됐습니다.

Entity 클래스의 경우에는 DB에서의 table 역할을 함.
Entity 클래스의 field들은 column 역할을 함.
JPA와 연동 되어있기 때문에 필수적으로 기본 생성자를 요구함.
id값을 AUTO로 잡아놨기 때문에(즉, 생성될 때마다 db에서 고유 id값을 부여하기 때문에)
@AllArgsConstructor를 적용하면 오류가 발생합니다.


Lombok이 적용되지 않았을 때의 기본적인 Entity class의 구조
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.NoArgsConstructor;

@Entity
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;
    
    private String firstName, lastName;
    
    // Lombok 사용하지 않고, 기본 생성자 및 ownerId를 제외한 RequiredArgsConstructor를 생성할 것
    // Lombok 사용하지 않고, 각 field에 대한 getter setter를 생성할 것

    public Owner() {}

    public Owner(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public Long getOwnerId() {
        return ownerId;
    }

    public void setOwnerId(Long ownerId) {
        this.ownerId = ownerId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
```

Lombok이 적용된 Entity Class의 구조

```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private final String firstName;
    private final String lastName;
}
```
- `@NoArgsConstructor(force = true)` : final 필드가 있는 경우에도 해당 필드를 null로 초기화하는 생성자를 강제로 생성해주기 때문에 `final` 키워드가 붙은 경우에도 JPA에서 요구되는 기본 생성자를 만들 수 있고, `@RequiredArgsConstructor`와도 충돌하지 않습니다.

http://localhost:8080/h2-console
들어가서 좌측 확인해보시면 OWNER table이 생성된 것을 확인할 수 있습니다.

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블을 만들겁니다. 일대다 관계는 소유자가 한 명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한 명이라는 의미입니다.

domain 패키지에 Owner이라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야 합니다. 그리고 OwnerRepository는 JpaReposiotry를 상속 받아야 합니다.

이상의 일대다 관계를 추가하려면 `@ManyToOne`과 `@OneToMany` 애너테이션(jakarta.persistence)을 이용해야 합니다. 외래 키를 포함한 Car 엔티티 클래스에서는 `@ManyToOne`을 사용할겁니다(이것 때문에 위에 부분 복사해왔습니다). 그리고 외래키를 추가했기 때문에 field 구성이 달라져야겠죠.

그럼 DB 적으로 봤을 때는 car table에다가 외래키인 ownerId를 추가하는 개념이라고 볼 수 있기 때문에 Car entity class에는 Owner 관련 field를 추가해야 합니다. 그렇다면 새로 추가된 field에 대한 getter / setter도 요구될겁니다. 모든 JOIN 관계에서는 FetchType.LAZY를 이용하는 것이 좋습니다. 대다(toMany) 관계의 경우에는 FetchType.LAZY가 기본값이므로 정의할 필요가 없지만 대일(toOne) 관계의 경우에는 반드시 명시해줘야 합니다.

FetchType : DB에서 데이터를 검색하는 전략을 정의. 속성값으로는
  EAGER : 즉시 검색
  LAZY : 지연 검색
저희 예제에서는 지연 검색(LAZY)은 DB에서 소유자를 검색하면 필요할 때 해당 소유자와 연관된 모든 자동차를 검색한다는 의미입니다. 반면 즉시 검색(EAGER)은 해당 소유자의 모든 자동차를 즉시 검색합니다.

```java
// Car.java
{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String brand, model, color, registrationNumber;
    private int modelYear, price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner")
    private Owner owner;

    public Owner getOwner() {
        return owner;
    }

    public void setOwner(Owner owner) {
        this.owner = owner;
    }

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }
}
// Owner.java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.List;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private String firstName;
    @NonNull
    private String lastName;

    // 소유자는 다수의 차들을 가질 수 있기 때문에 Collections를 사용.
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;
}
```
이상의 코드에서 `@Data`를 달아둔 경우에 일부러 겹치지만 Owner와 관련된 getter / setter를 코드로 써두었습니다. 반면에 `@Getter, @Setter`를 명시해둔 Owner 클래스에는 cars 관련 getter/ setter를 안 썼습니다. 당연히 프로젝트 하실 때는 setOwner() / getOwner()를 코드로 쓰실 필요가 없습니다.

Owner class의 `@OneToMany` 애너테이션에는 특성이 있습니다.
1. cascade 속성은 삭제 / 업데이트 시 연속 효과가 적용되는 방법을 지정합니다. 
  - ALL로 설정하게 되면 모든 작업이 연속적으로 적용됩니다.
  - 예를 들어 Owner를 삭제하게 되면 그 소유자와 연결된 Car 객체들도 전부 다 삭제됩니다.
2. mappedBy="owner" 속성 설정 : Car 클래스 사이에 이 관계의 외래 키인 owner 필드가 존재함을 명시함.

SQL을 배운 저희가 좀 어색하게 느껴질 수 있는 것은 ownerId 필드 하나만 가지고 와서 연결짓는게 아니라 Owner 클래스를 통째로 들고와서 Car에 field로 삼는다는 점입니다.

## H2 -> MariaDB로 이식
h2 version을 push합니다.

```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
//	runtimeOnly 'com.h2database:h2'
	runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	implementation 'org.projectlombok:lombok:1.18.42'
	annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```

```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:mariadb://localhost:3310/cardb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
```
spring.jpa.generate-ddl=true 설정은 JPA 가 데이터베이스를 초기화해야하는지(true/false) 여부를 정의합니다.

spring.jpa.hibernate.ddl-auto=create-drop 설정은 데이터베이스 초기화의 작동을 정의, 이용 가능한 값은 none / validate / update / create / create-drop 으로 기본값은 db 마다 다릅니다. h2 인메모리의 경우에는 기본적으로 create-drop 인데, mariadb 는 none 입니다.
  - create : 애플리케이션이 시작될 때 데이터베이스를 생성하기만 함(그래서 create로 해놓고 동일한 테이블명 설정해두면 오류납니다.)
  - update : 데이터베이스를 생성하고 스키마가 변경되면 수정
  - create-drop : 애플리케이션이 시작될때마다 db를 생성하고 중지될 때마다 삭제 -> 그래서 잦은 변경사항이 있는 개발환경에서는 얘를 쓰는 편입니다.

springboot 프로젝트 생성
entity class - repository의 관계성(Lombok 유무에 따른 코드 라인 변경 사항 작성)
mariadb 이식과 관련된 설정

CarDatabaseApplication에 CommandLineRunner를 활용한 더미 데이터를 넣는 것이 좀 번거롭습니다. 근데 create-drop 때문에 할 때마다 날라가서 쿼리문을 째로 복사해줬다가 실행할 때마다 붙여넣으시든지, main 부분에 작성해주시든지 해야 합니다.

# RESTful API Springboot ver.
Spring Data REST를 이용하여 CRUD 기능을 자동으로 제공하는 RESTful 웹 서비스를 만들고, 그것을 OpenAPI 3(Swagger)로 API 명세서도 만들어 볼 예정입니다.
## REST 기초
- 웹서비스를 제작하기 위한 아키텍처 스타일. Representation State Transfer 를 뜻하며 특정 언어나 플랫폼에 독립적이며 모바일 웹 / 기타 서비스와 같은 다양한 클라이언트들이 서로 통신할 수 있도록 함.
- 정해진 규칙이 있는 프레임워크라서 꼭 그에 맞게 작성하라는 의미는 아니고 제약 조건의 집합입니다.
- REST의 제약 조건
  1. 상태 비저장 : 서버는 클라이엍느 상태에 관한 어떤 정보도 저장하지 않음.
  2. 클라이언트-서버 간의 독립성 : 클라이언트와 서버는 독립적으로 작동해야 함. 서버는 클라이언트의 요청 없이 어떠한 정보도 전송해서는 안된다.
  3. 캐시 가능 : 여러 클라이언트가 동일한 리소스를 요청하는 경우가 많으므로 성능 향상을 위해 리소스에 캐싱을 적용해야 함.
  4. 일관된 인터페이스 : 서로 다른 클라이언트에 의한 요청이더라도 응답은 동일하게 보여야 함. 클라이언트의 예시로는 브라우저 / 자바 애플리케이션 / 모바일 애플리케이션 등
  5. 계층형 시스템 : 전체 서비스에 영향을 주지 않고 구성 요소를 추가하거나 수정할 수 있어야 함. 이 조건은 확장성과 관련 있음. 당근 마켓에 갑자기 지도 추가되거나 혹은 채팅이 추가되거나 등 기능이 추가되더라도 당근 마켓 자체가 멈추지 않음.
  6. 주문형 코드 : 선택 사항에 해당하는데, 대부분의 서버는 정적 컨텐츠를 JSON 또는 XML 형식으로 전송한다. 이는 서버가 정적 컨텐츠만이 아니라 실행 코드를 전송할 수 있도록 함.
- REST 아키텍처에 포함되면 좋은 요소들
  1. 리소스 식별 : 리소스는 고유 식별자(예를 들어 REST 서비스의 URI)로 식별해야 함. REST 리소스는 이해하기 쉬운 디렉토리 구조의 URI를 노출해야 함.
  2. 표현을 통한 리소스 조작 : 리소스를 요청할 때 서버는 리소스의 표현으로 응답해야 함. 일반적인 표현 형식으로는 JSON / XML
  3. 자체적인 설명 메시지 : 메시지는 서버가 처리 방법을 알 수 있는 충분한 정보가 포함되어야 함.
  4. HATEOAS(Hypermedia As The Engine Of Application State) : 응답에는 서비스의 다른 영역으로 연결되는 링크가 포함되어야 함.

## SpringBoot 로 RESTful API 웹 서비스 만들기
- Controller 클래스가 필요합니다. Controller는 모든 HTTP 요청을 처리하는 클래스를 의미합니다.
- cardatabase 패키지에 web이라는 패키지를 생성.
- web 패키지 내에 CarController라고 하는 Java class를 생성
```java
package com.example.cardatabase.web;

import org.springframework.web.bind.annotation.RestController;

@RestController // 해당 클래스의 RESTful API 웹 서비스 상의 Controller가 될 것을 지정함.
public class CarController {
}
```
- 메서드들이 포함될 겁니다. Controller 클래스의 메서드에는 메서드가 매핑되는 엔드포인트를 정의하는 @RequestMapping 애너테이션을 지정할겁니다. 예를 들어 `/cars` 엔드포인트로 GET 요청을 하게 됐을 때 getCars() 메서드를 호출하게 할 겁니다.
```java
package com.example.cardatabase.web;

import com.example.cardatabase.domain.Car;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class CarController {
    @GetMapping("/cars")
    public Iterable<Car> getCars() {
        // 자동차를 검색하고 반환
    }
}
```
gerCars() 메서드는 모든 자동차 객체를 반환한 다음에 Jackson 라이브러리에 의해서 자동으로 JSON 객체로 변환됩니다. 그리고 getCars() 메서드는 `@GetMapping` 애너테이션을 이용하기 때문에 `/cars` 엔드포인트의 GET 요청만 처리합니다. 즉 SQL문 상에서의 SELECT 요청만 처리한다는 의미입니다. 또한 `@PostMapping` 에서는 SQL문 상에서의 INSERT 요청만 처리한다는 뜻이 됩니다. `@---Mapping`만 보고서도 어떤 역할을 하는 method 인지 추측할 수 있습니다.

- HTTP 메서드
  1. `@PostMapping`
  2. `@GetMapping`
  3. `@DeleteMapping`

getCars()를 호출한다고 할 때 어디에서 자동차 목록을 가지고 올 수 있을지 생각해봐야 합니다.
```java
package com.example.cardatabase.web;

import com.example.cardatabase.domain.Car;
import com.example.cardatabase.domain.CarRepository;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class CarController {
    private final CarRepository carRepository;

    public CarController(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
    
    @GetMapping("/cars")
    public Iterable<Car> getCars() {
        return carRepository.findAll();
    }
}
```
자동차들이 저장되어있는 곳은 car 테이블이니까, SELECT * FROM car;를 호출 할 수 있는 CarRepository가 필요합니다. 그래서 CarController 에서 CarRepository를 사용할 수 있도록 field로 선언하고, final을 적용해서 Controller에 CarRepository가 포함되어 있는 매개변수 생성자를 만들었습니다. 그러면 CarController는 CarRepository에 딸려있는 메서드인 .findAll(); 을 통해서 전체 자동차 목록을 return 할 수 있게 됩니다.

현재 상황에서 생길 수 있는 문제를 검토하겠습니다.
1. 자동차 목록을 다 가지고 옵니다.
2. 근데 자동차 목록의 각각의 field 에는 Owner라 포함되어있습니다.
3. 근데 그 Owner 에는 cars 라고 하는 field 가 있습니다.
4. 그리고 그 cars list 내에는 각각의 element 로 car 객체들이 있습니다.
5. 그 car 의 객체의 field 로 Owner 가 포함되어있습니다.
6. 무한 반복

그래서 Owner.java 에 `@JsonIgnoreProperties({"hibernatedLazyInitializer", "handler"})`와 cars 필드에 `@JsonIgnore`를 적용하게 되면 무한 반복을 무시할 수 있습니다.
localhost:8080/cars




# gradle
- 소프트웨어 개발 프로세스를 간소화 및 통합하는 자동화 툴이며, _프로젝트 의존성을 관리하고 빌드 프로세스를 처리_ 한다.
- Springboot와 함께 메이븐(Maven)이라는 다른 프로젝트 관리 도구를 쓸 수도 있지만 가시성이 좋은 gradle을 선택했습니다.
- gradle의 구성은 프로젝트의 build.gradle 파일에서 수행. 이 파일은 프로젝트의 특정 요구 사항에 맞게 사용자가 지정 가능하며 소프트웨어 빌드, 테스트 및 배포와 같은 작업을 자동화하는 데 이용 가능.
- 이상의 파일은 일반적으로 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임워크 등 프로젝트의 의존성에 대한 정보를 포함
- build.gradle 파일을 작성할 때 Kotlin 또는 Groovy 프로그래밍 언어를 사용할 수 있음.(현재는 Groovy를 사용)

## 일반적인 build.gradle 내부의 항목
1. 플러그인(plugins) : 플러그인 블록은 프로젝트에서 쓰이는 gradle 플러그인을 정의하는 곳. 이제 롬복 뿐만 아니라 springboot 버전도 명시할겁니다.
2. 리포지토리(repository) : 의존성을 해결하는 데 쓰이는 의존성 리포지토리를 정의. 현재는 gradle이 의존성을 가죠오기 위해 Maven Central 리포지토리를 사용할 예정.
3. 의존성(dependencies) : 프로젝트에서 이용되는 _의존성_ 지정
4. 태스크(tasks) : 태스크 등의 빌드 프로세스의 일부인 태스크를 정의.

### 스프링 이니셜라이저 활용
https://start.spring.io/

```java
package com.example.cardatabase;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@SpringBootApplication
public class CardatabaseApplication {

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}
}
```
1. @EnableAutoconfiguration
    - 스프링부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동으로 구성되는데, 예를 들어 spring-boot-starter-web 의존성이 있는 경우 스프링 부트는 사용자가 웹 애플리케이션을 개발 중이라고 가정하고, 그에 따라 애플리케이션을 알아서 설정해줍니다.
2. @ComponentScan
    - 스프링 부트 컴포넌트 검색으로 애플리케이션의 모든 컴포넌트를 찾을 수 있도록 함.
3. @Configuration
    - Bean 정의를 제공하는 소스로 쓸 수 있는 클래스를 지정.
   
### Spring Boot Dev Tools
- 애플리케이션 개발 프로세스를 간략화해주는 의존성으로, 가장 중요한 것 중 하나는 클래스 경로의 파일이 수정될 때마다 스프링 부트 애플리케이션을 자동으로 재시작해준다는 겁니다.

### Logging / Problem-solution
- 로깅은 애플리케이션의 흐름을 모니터링하는 데 이용할 수 있고, 프로그램 코드의 예기치 않은 오류를 포착할 수 있는 좋은 방법입니다. Spring Boot Starter 패키지에는 별도의 구성 없이 로깅에 이용할 수 있는 LogBack이 있습니다.
- 로그백은 SLF4J(Simple Logging Facade For Java)를 기본 인터페이스로 사용합니다.

```java
package com.example.cardatabase;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {
	private static final Logger logger = LoggerFactory.getLogger(CardatabaseApplication.class);
	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started / 애플리케이션이 실행되었습니다.");
	}
}
```
주의할 점은 Logger 하나 import 하려고 할 때도 동일한 이름을 지닌 클래스 / 인터페이스가 많다는 점입니다. 그래서 앞으로 import 경로를 주의깊게 봐야합니다.

logger.info() : 로그 메시지를 콘솔에 출력합니다.

로깅 수준에는 TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF 7가지로 나뉩니다. 이를 application.properties에서 설정할 수 있습니다. 이는 resources 폴더 내에 있습니다. `logging.level.root=DEBUG`로 작성한다면, 로그 수준이 DEBUG 및 그 이상(즉, DEBUG / INFO / WARN / ERROR)에 해당하는 로그 메시지를 볼 수 있습니다. 다시 재시작하게 된다면 TRACE 관련 메시지는 표시되지 않습니다. 별도로 지정하지 않은 defalut 로깅 수준은 INFO에 해당합니다.

스프링부트의 기본 port 번호는 8080에 해당합니다. 가장 흔한 실수 중 하나는 코드를 수정하고 실행했을때 port number가 겹쳐서 실행이 안되는 점입니다. 

현재 port 구성
Springboot : 8080
MariaDB : 3310

# 의존성 주입(Dependency Injection)
## 정의
- 다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법.
- 클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지.
- 코드의 의존성을 줄이고 코드를 _재사용하기 쉽게_ 만들어줍니다.
- 의존성 주입의 3가지 클래스 유형
   1. 서비스(Service) : 클라이언트가 이용할 수 있는 클래스(의존성)
   2. 클라이언트(Client) : 의존성을 이용하는 클래스
   3. 주입기(injector) : 의존성(서비스)를 의존 클래스(클라이언트)에 전달.

의존성 주입을 통해 클래스를 느슨ㅅ하게 연결하는 것이 가능합니다. 즉, 클라이언트 의존성의 생성이 클라이언트의 작동과 분리되어 단위 테스트가 더 쉬워집니다.

일반적인 형태의 객체 생성 과정
```java
public class Car {
    private Owner owner;
    // 클래스와 이름이 같으니 생성자. 매개변수가 없으니 기본 생성자
    public Car() {
        this.owner = new Owner();
    }
}
```
클라이언트 클래스인 Car가 서비스 클래스(Owner)의 객체를 생성하기 때문에 의존성 주입이 없습니다.

```java
public class Car {
    private Owner owner;
    public Car(Owner owner) {
        this.owner = owner;
    }
}

public class CarMain{
   public static void main(String[] args) {
      Car car1 = new Car(new Owner());
      // 혹은
      Owner owner2 = new Owner();
      Car car2 = new Car(owner2);
   }
}
```
서비스 객체가 클라이언트 클래스에서 직접 생성되지 않습니다. 대신 클래스 생성자에서 매개변수로 전달됩니다. 여기서 클라이언트 클래스가 Car이고 의존성에 해당하는 것이 Owner라는 점입니다. 또한 서비스 클래스는 추상 클래스일 수도 있습니다. 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고, 테스트 중에는 Mock을 이용할 수 도 있습니다.

## 의존성 주입 유형
1. 생성자(Constructor) 주입 : 의존성이 클라이언트 클래스 생성자에게 전달되는 방식. 생성자 주입의 예시는 앞의 Car 코드에서 확인 가능합니다. 생성자 주입은 필수 의존성에 이용하는 것이 좋습니다. 모든 의존성은 클래스 생성자를 이용하여 제공되며 필수 의존성 없이는 객체를 생성할 수 없습니다.(즉, 매개변수 생성자를 이용하라는 의미)
2. 세터(Setter) 주입: 의존성이 세터를 통해 제공되는 방식입니다.
```java
public class Car {
    private Owner owner;
    public void setOwner(Owner owner) {
        this.owner = owner;
    }
}
```
세터 주입은 아무런 의존성이 없더라고 객체를 생성할 수 있기 땜누에 더 유연합니다. 이 접근 방식은 선택적 의존성을 허용해줍니다.

## 스프링 부트에서의 의존성 주입 이용
스프링 프레임워크에서 의존성 주입은 스프링 ApplicationContext를 통해 이루어집니다. 이는 객체(bean)와 객체의 의존성을 생성하고 관리하는 역할

스프링 부트 애플리케이션 클래스를 검색하여 특정 애너테이션(@Service / @Repository / @Controller 등)이 있는 클래스를 스프링 빈으로 등록합니다. 의존성을 주입하면 이러한 빈을 주입할 수 있습니다.

1. 생성자 주입
   - 생성자를 통해 의존성을 주입. 이 방법은 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게하므로 가장 권장되는 방법입니다. 가장 보편적인 상황은 특정 작업을 위해 DB에 대한 접근이 필요한 경우입니다. 스프링부트에서는 이를 위해 repository 클래스를 이용합니다.
```java
public class Car { 
    
    private final CarRepository carRepository;
    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
    // DB 상에서 CarRepository에 있는 모든 자동차 목록을 가져옴.
    carRepository.findAll(); // SELECT * FROM car;
    carRepository.findOwners(); // SELECT owner FROM car;
}
```
근데 클래스에 생성자가 여러 개 있는 경우 `@AutoWired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야 합니다.
```java
public class Car {
    private final CarRepository carRepository;

    // 의존성 주입에 이용하는 생성자
    @AutoWired
    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
}
```

2. 세터 주입 : 의존성은 세터 메서드를 통해 주입됩니다. 세터 주입은 선택적 의존성이 있거나 런타임에 의존성을 수정하려는 경우에 유용합니다.
```java
public class AppUserService {
    private AppUserService userService;
    
    // 일반적인 setter. call2() 유형
    @AutoWired 
    public void setAppUserRepository(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }
    // userRepository를 이용한 다른 메서드들을 여기서 사용할 수 있음.
}
```

3. 필드 주입 : 의존성을 필드에 직접 주입합니다. 가장 단순하지만 의존성을 사용할 수 없는 경우에 런타임 에러가 발생할 수 있고, 테스트를 위해서 모의 객체를 만드는게 아니라 그때그때 새로운 객체가 만들어지기 때문에 테스트하기가 좀 어렵습니다.
```java
@Service
public class CarDatabaseService implements CarService {
    // 여기에 Car 데이터베이스 서비스가 있다고 가정하겠습니다.
}

public class CarController {
    @AutoWired // 여기가 중요
    private CarDatabaseService carDatabaseService;
}
```

# JPA를 이용한 데이터베이스 생성 및 접근
Springboot와 함께 JPA(Jakarta Persistence API / Java Persistence API)를 이용하는 방법 및 Entity 클래스로 데이터베이스를 정의하는 방법을 학습.

H2 인메모리 데이터베이스라는 개념을 학습할겁니다. 그리고 H2에서 MariaDB로 이동을 시킬겁니다. 동시에 CRUD Repository를 생성하고, 데이터베이스의 테이블과 엔티티 클래스의 관계에 대해 학습하겠습니다.

## DRM / JPA / Hibernate
ORM / JPA는 RDB를 처리하기 위해 소프트웨어 개발에서 널리 이용되는 기술로, 복잡한 SQL 쿼리를 작성할 필요 없이 Java 개발자에게 친숙한 객체 형태로 DB를 조작할 수 있습니다. ORM / JPA는 SQL 코드 작성 및 디버깅에 소요되는 시간을 줄여줍니다.

대부분의 JPA 구현체들은 Java Entity 클래스를 바탕으로 DB의 스키마를 자동으로 생성할 수 있습니다.

1. ORM(Object Relational Mapping) : 객체지향 프로그래밍 패러다임을 이용하여 DB를 가져오고 매핑할 수 있는 기술. ORM은 데이터베이스 구조보다는 객체지향 개념을 바탕에 두고 있어서 Java 개발자가 굳이 SQL까지 배울 필요성을 줄여준다는 점에서 장점이 있습니다. 그리고 장점은 ORM으로 개발하게 되면 DB라는 독립적으로 구동되기 때문에 개발자가 이용하는 DBMS가 무엇인지에 따라 달라지는 SQL 문에 대해 걱정할 필요가 없습니다. -> DB 이식이 좀 수월합니다.
2. JPA : Java 개발자를 위한 객체-관계형 매핑을 제공. JPA 엔티티는 데이터베이스 테이블의 구조를 나타내는 Java 클래스에 해당합니다.
3. Hibernate : 최근에 가장 인기있는 JPA 구현체이고, 스프링 부트에서 기본 구현체로 이용됩니다. 대규모 애플리케이션에서 자주 쓰입니다.

## 엔티티 클래스(Entity)
JPA에서 @Entity 애너테이션을 이용하는 Java 클래스로, 표준 Java bean 명명 규칙도 따르고, 적절한 getter / setter 메서드도 가집니다. 그리고 private로 설정합니다. 애플리케이션이 초기화될 때 _클래스 이름으로 데이터베이스의 테이블을 생성_ 합니다. 만약에 다른 이름으로 지정하고 싶으면 엔티티 클래스에 @Table 애너테이션을 별개도 달 수도 있습니다.

1. field 명이 column명이 된다.
2. class 명이 table명이 된다.

H2 데이터베이스 / 
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	runtimeOnly 'com.h2database:h2'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

```java
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    
    private String brand, model, color, registrationNumber;
    
    private int modelYear, price;
```
1. @Id : DB에서의 테이블의 Primary Key에 해당하는 field에 달아주는 애너테이션
2. @GeneratedValue : 데이터베이스가 자동으로 ID를 생성하도록 지정(ID값을 우리가 객체 생성할 때 일일이 넣지 않는다는 것을 의미합니다. 다른 키 생성 전략을 사용할 수도 있습니다.). AUTO는 JPA 공급자가 특정 데이터베이스에 가장 적합한 전략을선택한다는 의미로, default값입니다.
- DB에서의 column명은 기본적으로 클래스 필드 명명 규칙에 따라 지정됩니다. 그래서 다른 컬럼명으로 지정하고 싶다면 @Column 애너테이션을 활용하여 커스텀할 수도 있습니다.
3. @Column : 컬럼명을 사용자화 / 컬럼의 길이 / 컬럼의 nullable 여부를 지정하는 것도 가능합니다.
```java
@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    
    @Column(name="explanation", nullable=false, length=512)
    private String description;
}
```
즉, Car 클래스의 description 필드는 car 테이블에서는 explantnio이라는 컬럼명을 갖게 되고, VARCHAR(512)로 데이터 길이가 저장도ㅓㅣ어있으며, null 불가라는 의미를 가지게 됩니다.

```java
spring.application.name=cardatabase
spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.show-sql=true
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
```

### CrudRepository의 추상 메소드 소개
1. long count() - 엔티티의 수를 반환
2. Iterable<T> - findAll() - 지정한 타입의 모든 항목을 반환                                          - Read
3. Optional<T> findById(ID id) - 지정한 ID의 한 항목을 반환(JS getElementById() 생각하시면 됩니다.)    - Read
4. void delete(T entity) - 엔티티 삭제                             - Delete
5. void deleteAll() - 리포지토리 내의 모든 엔티티를 삭제                - Delete
6. `<S extends T>` save(S entity) - 엔티티를 저장                   - Create
7. `List<S>` saveAll(`Iterable<S>` entities) - 여러 엔티티를 저장    - Create

## CRUD repository 생성
Spring Data Jpa에는 CRUD 작업을 위한 CrudRepository라는 인터페이스가 있습니다. 해당 인터페이스는 엔티티 클래스에 CRUD 기능을 제공합니다.

1. domain 패키지에 인터페이스인 CarRepository를 생성.
```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

public interface CarRepository extends CrudRepository<Car, Long> {
}
```
CarRepository는 스프링부트 JPA의 CrudRepository 인터페이스를 바탕으로 확장된 클래스입니다.(상속받음) 부모 클래스의 필드 / 메서드를 사용할 수 있습니다. 근데 둘 다 인터페이스니까 추상 메서드들을 상속받았다고 볼 수도 있습니다. 그리고 <Car, Long> 타입의 매개변수는 Car 엔티티 클래스의 Repositorydlrh, id 필드의 타입인 Long임을 명시했습니다. 제네릭으로 인해서 Car - CarRepository 관계가 Entity - Repository 관계로 성립됩니다.

method가 한 항목만 반환할 때는 T 대신에 `Optional<T>`를 반환합니다. Optional 클래스는 Java 8 SE에서 처음 도입된 타입으로, 값을 포함하거나 포함하지 않는 단일 값 컨테이너입니다.(특정 id값이 없는 경우에 보통 메서드 결과값이 오류로 발생하기 때문에 이를 막는 용도로 Optional을 사용합니다). 값이 있으면 isPresent() 메서드가 true를 반환하고, 없으면 false를 반환합니다. 그리고 값이 있을 때만 get() 메서드를 통해 값을 얻게 됩니다. 해당 Optional을 사용하게 되면 NullPointerException을 방지할 수 있습니다.

2. 이제 H2 인메모리에 예제 데이터들을 집어넣겠습니다. 인메모리 DB는 실행될 때마다 DB를 새로 만들고, 종료될 때 삭제하기 때문에 현재 h2-console에서 값을 입력해봤자 껏다 키면 없어집니다. 이를 방지하기 위해서 Springboot 프로젝트 내에 예제 데이터를 집어넣도록 할 겁니다.
```java
package com.example.cardatabase;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {

	}
}
```
다음, 새로운 Car 객체를 데이터베이스에 저장할 수 있도록 CarRepository를 main 클래스에 주입할겁니다.  

```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String brand, model, color, registrationNumber;

    private int modelYear, price;

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.id = id;
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }

    public Car() {
    }

    public Long getId() {
        return id;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public void setRegistrationNumber(String registrationNumber) {
        this.registrationNumber = registrationNumber;
    }

    public void setModelYear(int modelYear) {
        this.modelYear = modelYear;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public String getModel() {
        return model;
    }

    public String getColor() {
        return color;
    }

    public String getRegistrationNumber() {
        return registrationNumber;
    }

    public int getModelYear() {
        return modelYear;
    }

    public int getPrice() {
        return price;
    }

    public String getBrand() {
        return brand;
    }

    public void setId(Long id) {
        this.id = id;
    }
}
```
Car entity 클래스에서 기본 생성자 삭제했고, getter / setter도 삭제했음. 해당 부분을 Lombok 라이브러리 도입을 통해서 오류 해결

Spring Data Repository에 쿼리를 정의하는 것도 가능합니다. 쿼리는 접두사로 시작해야하고, 그 다음에는 쿼리에 이용할 엔티티 클래스 필드를 정의해야 합니다.

그러면 main에
```java
System.out.println(repository.findByBrand("Kia"));
```
콘솔 창에 `[Car(id=1, ...,)]`과 같은 형태로 나오게 됩니다.

`@Query` 애터테이션을 사용하면 직접 SQL문을 작성함으로써 쿼리 메서드를 만드는 것도 가능합니다.
```java
@Query("select c from Car where c.brand = ?1")
List<Car> findByBrand(String brand);
```
어차피 @Query가 있으나 없으나 List 부분은 똑같이 작성되는 것을 알수 있습니다. 그런데 복잡한 쿼리를 작성해야하거나, LIKE와 같은 고급 표현식을 사용할 때 적용한다.

```java
// SQL문을 활용한 브랜드로 자동차 검색
@Query("select c from Car c where c.brand = ?1")
List<Car> findByBrand(String brand);

// SQL을 활용한 브랜드로 자동차를 검색하는데 부분 검색을 적용
@Query("select c from Car c where c.brand like %?1")
List<Car> findByBrandEndsWith(String brand);

@Query("select c from Car c where c.brand like ?1%")
List<Car> findByBrandStartsWith(String brand);
```

Spring Data JPA에서는 CrudRepository로부터 확장된 PagingAndSortingRepository도 있습니다. 이 인터페이스는 페이징 및 정렬을 통해 엔티티를 검색하는 메서드를 제공합니다. 이 경우 대규머 결과 집합에서 모든 데이터를 처리하기에 적합합니다.
```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.PagingAndSortingRepository;

public interface CarRepository extends PagingAndSortingRepository<Car, Long> {
}
// 모든 자동차를 가져와서 Console에 로깅해보도록 하겠습니다.
//for (Car car : repository.findAll()) {
//    logger.info("brand : {}, model : {}", car.getBrand(), car.getModel());
//}

```

제공하는 메서드
1. Iterable<T> findAll(Sort sort) - 저장된 옵션으로 정렬된 모든 엔티티를 반환
2. Page<T> findAll(Pagable pagable) - 저장된 페이징 옵션으로 모든 엔티티를 반환

거의 JpaRepository를 많이 씁니다.

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블을 만들겁니다. 일대다 관계는 소유자가 한 명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한 명이라는 의미입니다.

domain 패키지에 Owner이라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야 합니다. 그리고 OwnerRepository는 JpaRepository를 상속받아야합니다.

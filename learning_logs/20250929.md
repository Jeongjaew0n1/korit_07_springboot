# MVC Pattern
- 정의 : 애플리케이션의 구조를 모델, 뷰, 컨트롤러라는 세 부분으로 분리하여 개발하는 방식
- 사용자 인터페이스를 갖춘 애플리케이션을 구조화하는 소프트웨어 디자인 패턴. 이는 비지니스 로직(데이터 처리), 사용자 인터페이스(화면 표시), 그리고 이 둘을 연결하는 제어 로직을 명확하게 분리하는 것을 목표
- MVC의 구성 요소
    - Model
      - 역할 : 데이터와 비지니스 로직을 담당. 애플리케이션이 '무엇을' 하는지에 대한 핵심적인 부분. 데이터의 저장, 처리, 조회, 변경 등의 작업을 수행하며, 사용자에게 보여줄 데이터 자체를 담고 있음.
      - SpringBoot 상에서의 형태 : Service 클래스, Repository(DAO) 클래스, 혹은 데이터 객체(DTO 또는 Entity) 등이 해당함.
    - View
      - 역할 : 사용자에게 _데이터를 시작적으로 보여주는 역할_ . 사용자의 입력(클릭, 폼 제출 등)을 받고 그 결과를 화면에 랜더링함. '어떻게' 보여줄지를 담당.
      - SpringBoot 상에서의 형태 : HTML / CSS / JS를 통해 구성된 페이지들이며, 주로 Thymeleaf, JSP(Java Server Page) 등의 템플릿 엔진을 사용하거나, REST API의 경우에는 JSON / XML 등의 데이터 형식으로 응답합니다. 근데 우리는 React로 연결할겁니다.
    - Controller
      - 역할 : 사용자의 요청을 받아 처리하고, Model과 View를 연결하는 중재자 역할. 사용자가 '무엇을 할지'에 대한 요청을 분석하고, Model 에게 필요한 작업을 지시한 후, 결과를 바탕으로 적절한 View를 선택하여 사용자에게 응답.
      - SpringBoot 상에서의 형태 : `@Controller, @RestController` 애너테이션이 붙은 클래스. `@RequestMapping` 등의 애너테이션으로 특정 URL 요청을 처리하는 메서드를 정의.

## Spring MVC의 동작 원리(요청 처리 흐름)
SpringBoot는 내부적으로 Spring MVC 프레임워크를 사용하여 MVC 패턴을 구현. 모든 요청을 처리하는 중앙 집중식 프론트 컨트롤러(Front Controller) 방식이 핵심.

- DispatcherServlet(디스패치 서블릿) : Spring MVC 의 core
  - 웹 애플리케이션으로 들어오는 모든 HTTP 요청을 가장 먼저 받아서 처리하는 프론트 컨트롤러 역할. SpringBoot는 내장된 웹 서버(보통 아파치 톰캣)을 사용하며, 별도의 복잡한 설정 없이 DispatcherServlet이 자동 설정됩니다.(Spring 으로 개발하면 이 서버 설정도 개발자가 함.)
- 요청 처리의 단계
  - 사용자가 웹 브라우저에서 특정 URL을 입력하거나 버튼을 클릭할 때(HTTP 요청 발생)부터 화면에 결과가 표시될 때 까지의 과정을 상세 설명합니다.
  1. 요청 수신(Request Reception)
     - 사용자의 요청(예시 : `GET /users/1`)이 `DispatcherServlet`으로 전달.
  2. 핸들러 매핑(Handler Mapping)
     - `DispatcherServlet`은 `HandlerMapping`에게 요청 URL을 처리할 적절한 Controller를 찾아달라고 요청.
     - `HandlerMapping`은 주로 `@Controller` 클래스의 `@RequestMapping` 애너테이션을 확인해서 요청을 처리할 특정 메서드를 찾게 됨.
  3. Controller 실행
     - `DispatcherServlet`은 찾은 Controller의 메서드를 `HandlerMapping`를 통해 실행.
     - Controller는 요청을 분석하여 Service/Repository/(Model) 계층에 데이터 처리를 요청함.
  4. ModelView 반환
     - Controller의 _처리 결과를 담은 Model 데이터와 View의 논리적 이름을 포함하는_ ModelAndView 객체(또는 View 이름명, 또는 Model 데이터만)를 `DispatcherServlet` 에게 return
  5. View 이름 해석(View Resolution)
     - `DispatcherServlet`은 `ViewResolver`에게 View의 논리적인 이름을 전달하여 실제 랜더링을 담당할 View 객체를 찾도록 요청.
  6. View 랜더링 및 응답(View Rendering & Response)
     - `DispatcherServlet`는 최종적으로 View 객체에게 Model 데이터를 전달하고 랜더링을 요청합니다.
     - View는 Model 데이터를 사용하여 최종적인 HTML 응답 페이지를 생성하고, 이 응답은 `DispatcherServlet`을 거쳐 사용자에게 전송됩니다.
     - `GET users/1`이면 DB 상에서의 user_id가 1인 애의 데이터를 이용하여 HTML 문서를 만들고, 2라면 user_id가 2인 애의 데이터를 활용하여 HTML 문서를 만들어서 브라우저로 보여준다고 보시면 됩니다.

## SpringBoot 3.5.6에서의 MVC 특정 및 구현 예시
SpringBoot 에서는 Spring MVC 를 자동으로 처리해주기 때문에 개발자는 핵심 로직에만 집중할 수 있습니다. 3.xx.xx 버전은 Java 17을 기반으로 하고, 설정 간소화와 편의성이 더 늘었습니다. 

- Controller 구현 예시
```java
@Controller
public class UserController {
    private final UserService userService; // Model 계층과의 상호작용을 위한 Service를 주입(Injection)
    
    // 생성자 주입
    public UserController(UserService userService) {
        this.userService = userService;
    }
}

// GET 요청으로 /uesrs/123
@GetMapping("/users/{userid}")
public String getUserDetail(@PathVariable Long userid, Model model) {
    // 1. Controller는 Model(Service)에 데이터 처리를 요청
    User user = userService.findUserById(userid);
    
    // 2. Controller는 Model 데이터를 View에 전달하기 위해 Model 객체를 담음
    model.addAttribute("user", user);
    model.addAttribute("pageTitle", "사용자 상세 정보");
    
    // 3. Controller는 View의 논리적 이름을 return
    // : (ViewResolver가 'user-detail' 에 해당하는 템플릿을 찾음)
    return "user-detail";
}
```
Thymeleaf를 활용하여 SpringBoot의 HTML 문서를 연결하는 방식

- Model(Service 계층) 구현 예시
  - Controller의 요청을 받아서 실제 비지니스 로직을 처리하는 영역.
```java
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User findUserById(Long id) {
        // UserRepository 에서 담겨있는 DB를 조회해서 Java 에서 쓸 수 있도록 해야함.
        User user = userRepository.findById(id);
        if (id == user.getId()) {
            return user;
        }
        return null;
    }
}
```

- 그 다음은 View 파트를 작성해야하는데, Thymeleaf로 쓰는 예시를 굳이 보여드릴 필요는 없을 것 같아서 그냥 지나가겠습니다. 저희는 React로 작성할겁니다. 혹시나 Thymeleaf 프레임워크의 예시가 궁금하시면 이상의 교재를 확인하시면 됩니다.
```Html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title th:text="${pageTitle}">사용자 상세</title> 
</head>
<body>
    <h1>사용자 상세 정보</h1>
    
    <p>ID: <span th:text="${user.id}">123</span></p>
    <p>이름: <span th:text="${user.name}">김철수</span></p>
    <p>이메일: <span th:text="${user.email}">chulsoo@email.com</span></p>
    
    <a href="/">돌아가기</a>
</body>
</html>
```

## MVC 패턴 사용의 장점
1. 관심사 분리(Seperation of Concerns)
   - 데이터 처리(Model), 화면 표시(View), 요청 처리(Controller)가 명확하게 분리되어 있어, 각 부분을 독립적으로 개발하고 수정할 수 있음.
     - 보여주는 부분이 잘못됐다. -> View 수정
     - DB에서 가져오기를 못한다. -> Repository or Service 수정
     - 요청 엔드포인트가 잘못됐다. -> Controller 수정 등
2. 높은 재사용성
   - 동일한 Model을 사용하여 여러 View를 만들 수 있음.
3. 유지 보수의 용이성
   - 화면 디자인이 변경되어도 Controller나 Model 코드는 거의 수정할 필요가 없습니다. 반대로, 비지니스 로직이 바뀌어도 View에 미치는 영향이 최소화됩니다.
   - 지금 카카오톡이 바뀐게 View가 바뀌었다고 볼 수 있습니다.
4. 테스트 용이성
   - 각 구성 요소가 독립적이기 때문에 단위 테스트를 쉽게 작성하고 수행할 수 있습니다.(GET 요청만 확인한다든지 등) 특히 Controller와 Model의 비지니스 로직은 View와 독립적으로 테스트 가능합니다.(Postman 으로, HeidiSQL로 CRUD 테스트를 마무리 지었습니다.)
5. 병렬 개발 가능
   - 프론트엔드 개발자(View)와 백엔드 개발자(Controller, Model)가 서로의 작업에 크게 영향을 주지 않으면서 동시 개발이 가능해 속도가 향상됩니다.

## 요약
1. MVC 는 Model / View / Controller를 _코드로 분리_ 하는 _디자인 패턴_ 입니다.
2. `DispatcherServlet` 이라는 프론트 컨트롤러를 통하여 요청을 처리합니다.
3. Controller는 요청을 받고 Model을 호출하여 View를 선택하는 중재자 역할을 합니다.
   - View 에서 요청(Request) -> Controller 내부의 코드에서 Service 호출 -> Service가 Repository를 호출하여 DB 관련 정보 습득 후 데이터 처리 -> Controller로 보내주면 -> Controller가 적절한 .html 문서를 응답(Response). / 저희는ㄴ ResponseEntity 를 쓸겁니다.
4. Model은 비지니스 로직과 데이터를 담당(Entity - Repository -> Service)

## Spring Initialize 를 통해서 cardatabase_4 를 만들겁니다.
https://start.spring.io/

# 프로젝트 만든 후에 실행 여부를 따졌을 때 실행이 되는 시점을 기준으로 합니다.
1. Car / CarRepository 를 만들었습니다.
   - 그런데 CarRepository 부분에서 JpaRepository 를 상속 받으려고 하니 검색이 안됐습니다. build.gradle에서 `implementation 'org.springframework.boot:spring-boot-starter-data-jpa'`가 없어서, 추가해주고 코끼리 눌렀습니다.
   - 오류가 계속 발생해 Car의 field로 Owner가 있는데 현재 Owner field가 없어서
2. Owner / OwnerRepository 를 생성했습니다.
   - application.properties에 관련 설정들을 넣지 않아서 실행이 되지 않습니다.
   - build.gradle에서 mariadb 관련 의존성도 넣지 않았습니다.
   - 이상의 설정들을 마무리 하고 스프링부트 애플리케이션을 실행시켰을 때의 결과값은
     - HeidiSQL 켜서 Car 테이블을 조회했을때, row=0인 테이블이 보입니다.
   - 하지만 Controller 파트를 작성하지 않았기 때문에 HeidiSQL에서는 데이터를 확인 및 추가가 가능하지만 postman을 통해서는 불가능합니다.
3. 이상의 과정에서 생긴 문제를 보니 MVC 패턴을 만들어야 postman 에서 CRUD를 할 수 있을 것 같습니다. 그러면 Model 하트에서 만든 Entity와 Repository를 제외하고 Service 파트도 만들어야하고, Controller 파트에 해당하는 Controller 클래스도 만들어야 합니다.
   - 루트 프로젝트 패키지에서 service 패키지 생성하고 CarService 생성
4. 그러면 이제 페이지를 보여줄 수 있도록 해야하는데, React와 연결할거라 View와 연결하는건 아니고 ResponseEntity와 연결하기 위한 CarController를 작성할겁니다.
   - 루트 프로젝트 패키지에서 Web 패키지 생성하고 CarController 생성

# .map()
함수형 프로그래밍의 핵심 개념 중 하나로, Collection 이나 컨테이너 객체 내부의 _각 요소를 변환_ 하여 새로운 컬렉션이나 컨테이너를 생성하는 데 사용.

## .map()의 정의
- 목적 : 컨테이너 객체 내부의 값을 다른 타입 또는 형태의 값으로 변환하여 새로운 컨테이너를 반환.
- 각 element에 적용될 변환 함수를 argument로 받습니다. -> 그래서 람다식이 필수적
- 원본 데이터는 변경하지 않고 변환된 element를 담는 _새로운 객체_ 를 만들어냅니다.

## .map()이 존재하는 주요 자료형(Java 기준)
1. `Optional<T>` : 값이 있을 수도 있고 없을 수도 있는 _단일 컨테이너_
   - 역할 : 값이 존재할 경우에만 그 값을 변환하고, 그 결과 다시 `Optional`로 감싸서 return. 값이 비어있는 경우에는 비어있는 Optional을
   - return
   - 예시 : `Optional<User>`를 `Optional<String>` 으로 변환할 때 사용 등.
2. `Stream<T>` : 데이터소스에서 element를 처리하기 위한 파이프라인을 구축하기 위해서 사용.
   - `역할 : Stream 내의 모든 element에 대하여 argument로 들어온 변환 함수를 적용하여, 변환된 element를 닫는 새로운 스트림을 생성.
   - 예시 : `Stream<String>`(단어 목록)을 `Stream<Integers>`(각 단어의 길이)로 변환
3. Collection : List, Set 등의 자료 구조
   - 역할 : 대부분의 객체 지향 언어에서 컬렉션이 자체적으로 .map()을 지원하는데. Java 에서는 컬렉션을 직접 변환하기 위해 사용
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## 예시
1. Stream에서 사용하기(가장 흔함)
```java
public class StreamMapExample {
  public static void main(String[] args) {
    List<Integer> numbers = Arrays.asList(1,2,3,4,5);

    // 1. stream 형태로 바꾸는 작업
    List<Integer> squaredNumbers = numbers.stream()
    // 2. .map()으로 각 element(1,2,3,4,5)에 n * n을 하도록 내부에 람다식 적용
      .map(n -> n*n)
    // 3. 현재는 stream이니까 다시 List로 바꿔줘야 합니다.
    .collect(Collectors.toList());

    System.out.printlin(SquaredNumbers); //결과값 : [1,4,9,16,25]
    System.out.printlin(numbers); // 결과값 : [1,2,3,4,5]
  }
}
```

2. Optional에서 사용하기(값의 안전한 접근 및 변환)
   예를 들어 User 객체에서 이메일 주소만 가지고 오는데, User 객체가 존재할 때만 동작하도록 보장
```java
class User {
  private String email;
  publc User(String email) { this.email = email; }
  public String getEmail() { return email; }
}

public class OptionalMapExample {
  // 사용자를 찾지 못했을 때는 비어있는 Optional을 반환하는 메서드 정의할겁니다
  //(우리가 이런걸 안쓴 이유는 extends JpaRepository 때문이라는 거 잊지 마세요)
  public static Optional<User> findUser(boolean found) {
    // return에 삼항연산자 쓸겁니다.
    return found ? Optional.of(new User("kim1@test.com"))  : Optional.empty(); 
  }

  public static void main(String[] args) {
    // 1. User 객체가 있는 경우를 예시로.
    String emailFound = findUser(true)
    // User 객체가 있으면 getEmail() 메서드를 호출하여 String으로 변환할 수 있도록 .map() 적용
    .map(User:: getEmail)
    // 만약에 Optional<String>이 비어있으면 "N/A"를 반환하도록 작성
    .orElse("N/A");

    System.out.println("E-mail : " + emailFound); // 결과값 : E-mail :  kim1@test.com

    String emailNotFound = findUser(false)
    // User 객체가 있으면 getEmail() 메서드를 호출하여 String으로 변환할 수 있도록 .map() 적용
    .map(User:: getEmail)
    // 만약에 Optional<String>이 비어있으면 "N/A"를 반환하도록 작성
    .orElse("N/A");

        System.out.println("E-mail : " + emailFound); // 결과값 : E-mail :  N/A
  }
}

```

20250929 15:40 기준으로 Car Entity를 기준으로 한 CRUD 전체를 구현했습니다. DBMS 및 postman에서의 확인도 끝남.
Owner 기준으로 전체를 다 만들면 됨.
Service / Controller에 구현할 목록 -> Owner 전체 조회 / id 별 조회 / Owner 객체 추가 / Owner 객체 삭제 / Owner 객체 수정
